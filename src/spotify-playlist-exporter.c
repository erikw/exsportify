#include "spotify-playlist-exporter.h"

#define _POSIX_C_SOURCE  199309L	// Needed to get clock_gettime to work.

#include <pthread.h>
#include <sys/time.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdbool.h>
#include <string.h>

#include <pthread.h>
#include <libspotify/api.h>

#define USER_AGENT "spotify-playlist-exporter"

sp_session *g_session;
static bool notify_events;
static pthread_mutex_t notify_mutex;
static pthread_cond_t notify_cond;


static void connection_error(sp_session *session, sp_error error)
{
	
}

static void logged_in(sp_session *session, sp_error error)
{
	if (error == SP_ERROR_OK) {
		printf("Logged in!\n");
	} else {
		fprintf(stderr, "could not login: %s\n",
				sp_error_message(error));
	}
	
}

static void logged_out(sp_session *session)
{
	exit(EXIT_SUCCESS);
}


/**
 * This callback is called for log messages.
 *
 * @sa sp_session_callbacks#log_message
 */
static void log_message(sp_session *session, const char *data)
{
	fprintf(stderr,"%s",data);
}

void notify_main_thread(sp_session *session)
{
	pthread_mutex_lock(&notify_mutex);
	notify_events = true;
	pthread_cond_signal(&notify_cond);
	pthread_mutex_unlock(&notify_mutex);
}

static sp_session_callbacks callbacks;

int spotify_init(const char *username,const char *password)
{
	sp_session_config config;
	sp_error error;
	sp_session *session;

	// Default values to 0.
	memset(&config, 0, sizeof(sp_session_config));
	
	/// The application key is specific to each project, and allows Spotify
	/// to produce statistics on how our service is used.
	extern const char g_appkey[];
	/// The size of the application key.
	extern const size_t g_appkey_size;

	// Always do this. It allows libspotify to check for
	// header/library inconsistencies.
	config.api_version = SPOTIFY_API_VERSION;

	// The path of the directory to store the cache. This must be specified.
	// Please read the documentation on preferred values.
	config.cache_location = "cache";

	// The path of the directory to store the settings. 
	// This must be specified.
	// Please read the documentation on preferred values.
	config.settings_location = "cache";

	// The key of the application. They are generated by Spotify,
	// and are specific to each application using libspotify.
	config.application_key = g_appkey;
	config.application_key_size = g_appkey_size;

	// This identifies the application using some
	// free-text string [1, 255] characters.
	config.user_agent = USER_AGENT;


	// Register the callbacks.
	callbacks.logged_in = logged_in;
	callbacks.logged_out = logged_out;
	callbacks.connection_error = connection_error;
	callbacks.notify_main_thread = notify_main_thread;
	callbacks.log_message = log_message;

	config.callbacks = &callbacks;

	error = sp_session_create(&config, &session);
	if (SP_ERROR_OK != error) {
		fprintf(stderr, "failed to create session: %s\n",
		                sp_error_message(error));
		return 2;
	}

	// Login using the credentials given on the command line.
	error = sp_session_login(session, username, password, false, NULL);

	if (SP_ERROR_OK != error) {
		fprintf(stderr, "failed to login: %s\n",
		                sp_error_message(error));
		return 3;
	}

	g_session = session;
	return 0;
}

int main(int argc, char **argv)
{
	int next_timeout = 0;
	if (argc < 3) {
		fprintf(stderr,"Usage: %s <username> <password>\n",argv[0]);
	}
	pthread_mutex_init(&notify_mutex, NULL);
	pthread_cond_init(&notify_cond, NULL);

	// TODO allow for argc == 1 and try logging in from cache.  Like spshell
	if (spotify_init(argv[1], argv[2]) != 0) {
		fprintf(stderr,"Spotify failed to initialize\n");
		exit(-1);
	}
	pthread_mutex_lock(&notify_mutex);
	for (;;) {
		if (next_timeout == 0) {
			while (!notify_events)
				pthread_cond_wait(&notify_cond, &notify_mutex);
		} else {
			struct timespec ts;

	#if _POSIX_TIMERS > 0
			clock_gettime(CLOCK_REALTIME, &ts);
	#else
			struct timeval tv;
			gettimeofday(&tv, NULL);
			TIMEVAL_TO_TIMESPEC(&tv, &ts);
	#endif

			ts.tv_sec += next_timeout / 1000;
			ts.tv_nsec += (next_timeout % 1000) * 1000000;

			while (!notify_events) {
				if (pthread_cond_timedwait(&notify_cond, &notify_mutex, &ts))
					break;
			}
		}

		// Process libspotify events
		notify_events = false;
		pthread_mutex_unlock(&notify_mutex);

		do {
			sp_session_process_events(g_session, &next_timeout);
		} while (next_timeout == 0);

		pthread_mutex_lock(&notify_mutex);
	}
	sp_session_release(g_session);
	return EXIT_SUCCESS;
}
