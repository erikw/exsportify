#include <iostream>
#include <string>
#include <cstdlib>

#include <unistd.h>
#include <termios.h>

#include <boost/program_options.hpp>
#include <boost/thread/thread.hpp>
#include <libspotify/api.h>

#include "exsportify.h"
#include "debug.h"
#include "event_loop.h"
#include "session.h"
#include "spotify.h"

extern "C" {
#include "appkey.h"
}

#define USER_AGENT PROGRAM_NAME

namespace bpo = boost::program_options;

static const char *USAGE_DESC = "Make a backup of all your playlists.";

static void parse_args(int argc, const char *argv[], std::string &username,
		std::string &password, bool &store_session, bool &load_session) {
	bpo::options_description desc("Possible options. Either log in always or"
			" store a login session for later reuse. Typically you "
			"will log in once and reuse the session on future "
			"(scripted) runs.");
	desc.add_options()
		("help,h", "Show help message.")
		("version,v", "Print version and exit.")
		("store-session,s", "Store the login session.")
		("load-session,l", "Login using stored session.")
		("username,u", bpo::value<std::string>(&username),
		 	 "Spotify/Facebook username")
		("password,p", bpo::value<std::string>(&password),
		 	 "Your password. Can be omitted.")
		;

	bpo::variables_map vmap;
	try {
		bpo::store(bpo::parse_command_line(argc, argv, desc), vmap);
		if (vmap.count("help")) {
			std::cout << USAGE_DESC << std::endl;
			std::cout << desc;
			exit(EXIT_SUCCESS);
		}
		bpo::notify(vmap); // Throw errors if there are any.

		if (vmap.count("version")) {
			std::cout << PROGRAM_NAME << " v" <<
				EXSPORTIFY_VERSION_MAJOR << "." <<
				EXSPORTIFY_VERSION_MINOR << std::endl;
			exit(EXIT_SUCCESS);
		}

		if (vmap.count("store-session")) {
			store_session = true;
		}

		if (vmap.count("load-session")) {
			load_session = true;
		}

		if (!load_session) {
			if (!vmap.count("username")) {
				std::cout << "username: ";
				std::getline(std::cin, username);
			}

			if (!vmap.count("password")) {
				std::cout << "password: ";
				termios termattr_old;
				tcgetattr(STDIN_FILENO, &termattr_old);
				termios termattr_new = termattr_old;
				termattr_new.c_lflag &= ~ECHO;
				tcsetattr(STDIN_FILENO, TCSANOW, &termattr_new);
				//std::cin >> password;
				std::getline(std::cin, password);
				tcsetattr(STDIN_FILENO, TCSANOW, &termattr_old);
				std::cout << std::endl;
			}
		}
	} catch (bpo::error &err) {
		std::cerr << "Command parsing failed:" << err.what() << "." <<
			std::endl;
	}
}

static int spotify_init(std::string &username, std::string &password,
			bool &store_session, bool &load_session) {
	sp_session_config config;
	sp_error error;
	sp_session *session;

	// Default values to 0.
	memset(&config, 0, sizeof(sp_session_config));

	/// The application key is specific to each project, and allows Spotify
	/// to produce statistics on how our service is used.
	//extern const char g_appkey[];
	/// The size of the application key.
	//extern const size_t g_appkey_size;

	// Always do this. It allows libspotify to check for
	// header/library inconsistencies.
	config.api_version = SPOTIFY_API_VERSION;

	// The path of the directory to store the cache. This must be specified.
	// Please read the documentation on preferred values.
	config.cache_location = "cache";

	// The path of the directory to store the settings.
	// This must be specified.
	// Please read the documentation on preferred values.
	config.settings_location = "cache";

	// The key of the application. They are generated by Spotify,
	// and are specific to each application using libspotify.
	config.application_key = g_appkey;
	config.application_key_size = g_appkey_size;

	// This identifies the application using some
	// free-text string [1, 255] characters.
	config.user_agent = USER_AGENT;


	// Register the callbacks.
	config.callbacks = &session_callbacks;

	error = sp_session_create(&config, &session);
	if (SP_ERROR_OK != error) {
		BOOST_LOG_TRIVIAL(error)
		    << "Failed to create session: " << sp_error_message(error);
		return 2;
	}


	if (load_session) {
		error = sp_session_relogin(session);
		if (error == SP_ERROR_NO_CREDENTIALS) {
			BOOST_LOG_TRIVIAL(error) << "No credentials stored!";
			return 3;
		}
		char remembered_username[256];
		sp_session_remembered_user(session, remembered_username,
					   sizeof(remembered_username));
		BOOST_LOG_TRIVIAL(trace) << "Logged in with stored user \""
					 << remembered_username << "\"";
	} else {
		error = sp_session_login(session, username.c_str(), password.c_str(),
				 store_session, NULL);
		if (error != SP_ERROR_OK) {
			BOOST_LOG_TRIVIAL(error)
		    	    << "failed to login: " << sp_error_message(error);
			return 4;
		}
	}

	spotify.mutex.lock();
	spotify.session = session;
	spotify.mutex.unlock();
	return 0;
}

static void boost_init(void) {
#ifdef DEBUG
	boost::log::core::get()->set_filter (
    			boost::log::trivial::severity >= boost::log::trivial::trace
    			);
#else
	boost::log::core::get()->set_filter (
    			boost::log::trivial::severity >= boost::log::trivial::error
    			);
#endif
}

int main(int argc, const char *argv[]) {
	std::string username;
	std::string password;
	bool store_session = false;
	bool load_session = false;

	boost_init();
	BOOST_LOG_TRIVIAL(trace) << "Reading command line arguments.";
	parse_args(argc, argv, username, password, store_session, load_session);

	if (spotify_init(username, password, store_session, load_session) !=
	    0) {
		BOOST_LOG_TRIVIAL(error) << "Spotify failed to initialize";
		exit(EXIT_FAILURE);
	}
	boost::thread event_thread = boost::thread(event_loop());

	event_thread.join();

	return EXIT_SUCCESS;
}
